#!/bin/bash
# best-effort script for auto generating bugpoint_input.sv and template bugpoint_check.sh
# usage:
# 1) issue bugpoint_verilator_gen --init
# 2) prepend and run each command needed for bug replication with bugpoint_verilator_gen

quote_cmd() {
  for i in "$@"; do
     printf '%q ' "$i"
  done
}

record_generic_cmd() {
  quote_cmd "$@" >> bugpoint_check.sh
  "$@"
  EXIT_CODE="$?"
  if [ "$EXIT_CODE" -eq 0 ]; then
    printf "|| exit \$?\n" >> bugpoint_check.sh
  else
    printf "\n" >> bugpoint_check.sh
  fi
}

record_verilator() {
  # preprocess
  "$@" -E -P > bugpoint_input.sv
  # make invocation for building preprocessed file
  STRIPPED_CMD=$(bugpoint_strip_verilator_cmd "$@")"\$1"
  # run original cmd, and capture stderr
  STDERR=$("$@" 2>&1 1>/dev/null)
  EXIT_CODE="$?"

  if [ "$EXIT_CODE" -eq 0 ]; then
    printf "%s 2>/dev/null || exit \$?\n" "$STRIPPED_CMD" >> bugpoint_check.sh
  else # build failed, create assert on stderr
    printf "%s\n" "$STDERR" | bugpoint_strip_verilator_errmsg > golden_stderr
    cat >>bugpoint_check.sh <<EOF
$STRIPPED_CMD 2>&1 1>/dev/null | bugpoint_strip_verilator_errmsg > actual_stderr

printf "\n\n\n"
diff golden_stderr actual_stderr --color && printf "SUCCESS\n\n\n"
EXIT_CODE=\$?

[ -n "\$GOLDEN" ] && cp actual_stderr golden_stderr

exit "\$EXIT_CODE"
EOF
  fi
}

if [ "$1" = "--init" ]; then
  printf "#!/bin/sh\n" > bugpoint_check.sh
  chmod +x bugpoint_check.sh
elif [ "$1" = "verilator" ]; then
  record_verilator "$@"
else
  record_generic_cmd "$@"
fi
